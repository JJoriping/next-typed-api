import { existsSync } from "fs";
import { resolve } from "path";
import { warning } from "@daldalso/logger";
import { Project, SyntaxKind } from "ts-morph";

const appRouterKeywords = [ "GET", "HEAD", "POST", "PUT", "DELETE", "PATCH", "OPTIONS" ];
const typeTextPattern = /@daldalso\/next-typed-route\b/;
const dynamicSegmentPatterns = {
  normal: /\[(\w+?)]/g,
  catchAll: /\[\.{3}(\w+?)]/g,
  optionalCatchAll: /\[\[\.{3}(\w+?)]]/g
};

let project:Project;

export function initialize(rootPath:string):void{
  const tsConfigFilePath = resolve(rootPath, "tsconfig.json");
  if(!existsSync(tsConfigFilePath)){
    throw Error("Could not find tsconfig.json");
  }
  project = new Project({ tsConfigFilePath });
}
export function generateEndpoint(key:string, path:string):string|undefined{
  const R = [
    "// Auto-generated by @daldalso/next-typed-route"
  ];
  const parametersType = getParametersType(key);
  const file = project.addSourceFileAtPath(path);
  let accepted = false;

  for(const v of file.getImportDeclarations()){
    R.push(v.getText());
  }
  for(const v of file.getTypeAliases()){
    R.push(v.getText());
  }
  for(const v of file.getInterfaces()){
    R.push(v.getText());
  }
  R.push(
    "import type { Endpoint } from \"@daldalso/next-typed-route\";",
    "export module \"@daldalso/next-typed-route\"{",
    "  export interface NextRoutingTable{"
  );
  for(const [ k, v ] of file.getExportedDeclarations()){
    if(!appRouterKeywords.includes(k)) continue;
    for(const w of v){
      if(!w.isKind(SyntaxKind.VariableDeclaration)) continue;
      const typeNode = w.getTypeNode();
      if(!typeNode?.isKind(SyntaxKind.TypeReference)){
        warning(`Unexpected type "${typeNode?.getText()}" for the variable "${k}"`)['Path'](path);
        continue;
      }
      const typeText = typeNode.getType().getText();
      if(!typeTextPattern.test(typeText)){
        warning(`Unexpected type "${typeText}" for the variable "${k}"`)['Path'](path);
        continue;
      }
      const [ requestType, responseType ] = typeNode.getTypeArguments();

      R.push(`    '${k} /${key}':Endpoint<${requestType ? requestType.getText() : "unknown"}&{ params: ${parametersType} }, ${responseType ? responseType.getText() : "void"}>;`);
      accepted = true;
    }
  }
  project.removeSourceFile(file);
  if(accepted){
    R.push("  }", "}");
    return R.join('\n');
  }
  return undefined;
}
export function getParametersType(key:string):string{
  const R:Record<string, string> = {};

  key.replace(dynamicSegmentPatterns.optionalCatchAll, (_, g1:string) => {
    R[g1] = "string[]|undefined";
    return "*";
  }).replace(dynamicSegmentPatterns.catchAll, (_, g1:string) => {
    R[g1] = "string[]";
    return "*";
  }).replace(dynamicSegmentPatterns.normal, (_, g1:string) => {
    R[g1] = "string";
    return "*";
  });
  if(Object.keys(R).length){
    return "{" + Object.entries(R).map(([ k, v ]) => `'${k}':${v}`).join(',') + "}";
  }
  return "unknown";
}